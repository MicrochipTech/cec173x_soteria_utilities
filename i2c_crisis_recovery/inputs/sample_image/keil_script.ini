
//RESET
kill button *
define button "READ_EFUSE ", "ProgEfuseREAD() "
define button "ENTER_RAW ", "raw_mode_test()"
define button "LIFE_REQ ", "set_life_req() "
define button "RAW_BNDRY_SCAN ", "raw_mode_set_bndry_scan() "
define button "DEBUG_REG_STATE", "print_debug_reg_state()"
define button "ENTER_MFG", "enter_mfg_mode()"
define button "EXIT_ATE_MODE", "exit_ate_mode()"
define button "ENTER_FULL_PROV_MODE", "enter_full_prov_mode()"
define button "MFG_TO_DEV", "set_life_rq_change_from_mfg()"
define button "QA_FTR_DIS", "qa_mode_feature_disable()"
define button "QA_STAP_EN", "qa_mode_enable_stap()"
define button "VALID_STAP_EN","valid_mode_enable_stap()"
define button "TST_RQST", "set_tst_rqst()"
define button "SOFT_RESET", "soft_reset()"
define button "EFUSE_ECDH", "ProgEfuseEN_ECDH(); g;"
define button "LD_CNTNR ", "LOAD create_container.hex "
define button "EN_UN_XFR_CMD ", "LOAD unrestricted_transfer_cmd.hex "

DEFINE UNSIGNED LONG key_type_change_step;
key_type_change_step = 0x00;

DEFINE UNSIGNED LONG tag_changed;
tag_changed = 0x00;


DEFINE UNSIGNED LONG step_once;
step_once = 0x00;

DEFINE UNSIGNED LONG step_once_2;
step_once_2 = 0x00;

DEFINE UNSIGNED LONG reg_life_cycle_count;
reg_life_cycle_count = 0x00;

DEFINE UNSIGNED LONG life_cycle_iter;
life_cycle_iter = 0x00;

DEFINE UNSIGNED LONG life_cycle_iter_reg;
life_cycle_iter_reg = 0x00;

DEFINE UNSIGNED LONG mfg_transition;
mfg_transition = 0x00;

DEFINE UNSIGNED LONG dev_transition;
dev_transition = 0x00;

DEFINE UNSIGNED LONG pro_transition;
dev_transition = 0x00;

DEFINE UNSIGNED LONG fa_transition;
dev_transition = 0x00;

DEFINE UNSIGNED LONG eFuseAddr;
eFuseAddr = 0xF300;

DEFINE UNSIGNED CHAR port_iteration;
port_iteration =0;

DEFINE UNSIGNED CHAR reg_iteration;
reg_iteration =0;

DEFINE UNSIGNED CHAR cs_select;
cs_select = 0;

DEFINE UNSIGNED CHAR tag0_failed;
tag0_failed = 0;

DEFINE UNSIGNED CHAR tag1_load;
tag1_load = 0;

DEFINE UNSIGNED CHAR read_qspiport_reg;
read_qspiport_reg = 0x00;

DEFINE UNSIGNED CHAR port_value;
port_value = 0x00;

DEFINE UNSIGNED CHAR case_num;
case_num = 0x01;

DEFINE UNSIGNED CHAR AUTHEN;
AUTHEN = 0x01
DEFINE UNSIGNED CHAR ENCRYP;
ENCRYP = 0x02
DEFINE UNSIGNED CHAR DEV_ID_L;
DEFINE UNSIGNED CHAR DEV_ID_H;

DEFINE UNSIGNED CHAR once;
once =1;

DEFINE UNSIGNED CHAR IMAG;
IMAG = 0;
DEFINE UNSIGNED CHAR SRC;
SRC = 0;


DEFINE UNSIGNED CHAR RUN_TST;
RUN_TST = 1;
DEFINE CHAR SPI_TEST;
SPI_TEST = 0;
DEFINE CHAR AUT_ENC;
AUT_ENC = 0;

DEFINE UNSIGNED CHAR TST_NO;
DEFINE UNSIGNED CHAR TST_NO_1;

DEFINE UNSIGNED CHAR BOOT_OPT_48; //For SRAM size
DEFINE UNSIGNED CHAR BOOT_OPT_49;
DEFINE UNSIGNED CHAR BOOT_OPT_50;
DEFINE UNSIGNED CHAR BOOT_OPT_92;
DEFINE UNSIGNED CHAR BOOT_OPT_88;
DEFINE UNSIGNED CHAR BOOT_OPT_89;
DEFINE UNSIGNED CHAR BOOT_OPT_1011;//For Authentication and Encryption
DEFINE UNSIGNED CHAR BOOT_OPT_1010;//For Debug enable disbale


DEFINE UNSIGNED CHAR TAGIMAGLOC;
TAGIMAGLOC = 0x7b000840;

DEFINE UNSIGNED CHAR NO_OF_TIMES;
NO_OF_TIMES = 1;

FUNC void print_help(int idx, int efdata) {
    if (once){
        //
    }
}

FUNC int ef16data(int lsb_byte, int msb_byte)
{
    return ((lsb_byte + (msb_byte << 8)) & 0xFFFF);
}


FUNC void ProgEfuseWrite(int index, int efd) {
    int b;
    int addr, data1;
    int busy;

    b = 0;
    addr = 0;

    _WBYTE(0x40082000, 0x00); // Take the OTP out of power down by clearing PWRDN_N in the OTP Power Down Register
//     printf("0x40082000 %X\n", _RBYTE(0x40082000));

    _WBYTE(0x40082010, 0x01);
    _WBYTE(0x40082005, 0x01); // Program byte mode programming accordingly by setting PGM_MODE_BYTE.
    //Program the various pulse width CSRs.
    _WBYTE(0x40082015, 0x2); //0x1); // 0x60 //OTP Reset Pulse Width Registe
    _WBYTE(0x40082019, 0xD0);//0xC0); // 0x60 //OTP Program Pulse Width Register
    _WBYTE(0x4008201D, 0x7); //0x5); // 0x60 //OTP Reset Pulse Width Registerr
    //Reset
    _WBYTE(0x40082008, 0x04); //Set the PROGRAM Command bit in the OTP Function Command Register
    _WBYTE(0x4008200A, 0x01); //Set the GO Command bit in the OTP Go Command Register

   // _WBYTE(0x40082018, 0x60); //Program the various pulse width CSRs.
    addr = (index << 8);
    //printf("@Address[%04d] = ", index);
    _WBYTE(0x40082003, (addr & 0x03));      //Write to the OTP Address Register bit [2:0]
    _WBYTE(0x40082002, ((addr & 0xFF00)>>8));  //Write to the OTP Address Register bit [10:3]
    _WBYTE(0x40082001, ((addr & 0xFF0000)>>16));//Write to the OTP Address Register bit [15:11]

    _WBYTE(0x40082004, (efd & 0xFF)); //OTP Program Data Register
    _WBYTE(0x40082008, 0x02); //Set the PROGRAM Command bit in the OTP Function Command Register
    _WBYTE(0x4008200A, 0x01); //Set the GO Command bit in the OTP Go Command Register
    addr = 10;
    while (addr > 0) {
        addr--;
    }
    busy = _RBYTE(0x40082010);
  //  printf("Interrupt %X\n", busy);
    _WBYTE(0x40082010, 0x01);

    busy = _RBYTE(0x4008200C);
    //printf("Busy %X\n", busy);

    _WBYTE(0x40082008, 0x01); //Set the READ Command bit in the OTP Function Command Register
    _WBYTE(0x4008200A, 0x01); //Set the GO Command bit in the OTP Go Command Register
    addr = 10;
    while (addr > 0) {
     addr--;
    }
    busy = _RBYTE(0x4008200C);
  //  printf("busy %X\n", busy);
    _WBYTE(0x40082010, 0x01);
    data1 = _RBYTE(0x40082006); //the OTP Read Data Register
    //printf(" %02X\n", data1);
}

FUNC void ProgEfuseREAD(void) {
    int idx, loop1;
    int data1;
    int busy;

    _WBYTE(0x40082000, 0x00); // Take the OTP out of power down by clearing PWRDN_N in the OTP Power Down Register
    _WBYTE(0x40082015, 0x1); // 0x60 //OTP Reset Pulse Width Registe
    _WBYTE(0x40082019, 0xC0); // 0x60 //OTP Program Pulse Width Register
    _WBYTE(0x4008201D, 0x5); // 0x60 //OTP Reset Pulse Width Registerr
    for (idx = 0; idx < 1024; idx++) {
        _WBYTE(0x40082002, ((idx & 0xFF)));  //Write to the OTP Address Register bit [10:3]
        _WBYTE(0x40082001, ((idx & 0x1F00)>>8));//Write to the OTP Address Register bit [15:11]
        _WBYTE(0x40082008, 0x01); //Set the READ Command bit in the OTP Function Command Register
        _WBYTE(0x4008200A, 0x01); //Set the GO Command bit in the OTP Go Command Register
        loop1 = 10;
        while (loop1 > 0) {
            loop1--;
        }
        busy = _RBYTE(0x4008200C);
       // printf("Busy %X\n", busy);
        data1 = _RBYTE(0x40082006); //the OTP Read Data Register
        printf("Data[%04d]= %02X\n",idx, data1);
        _WBYTE(0x40082010, 0x01); //Clear OTP_READY interrupt by clearing READY_INTR_STATUS
    }
}
/* idx in [0, 255]
 * Program non-zero bits from bits[15:0] of efdata
 */
FUNC void ProgEfuseHword(int index, int efd)
{
    int dat, idx;

    idx = ((index  << 1 ) & 0x1FFF);
    dat = (efd & 0xFF);
    ProgEfuseWrite(idx, dat);

    idx = (idx + 1);
    dat = ((efd >> 8)& 0xFF);
    ProgEfuseWrite(idx, dat);
}


FUNC void soft_otp_delay()
{   
	  int idx;
	  int efdata;

    idx = 0;
    efdata = 0;
	  for(idx = 304; idx < 353; idx++) {
			   if(idx%2 == 0)
				 { 
					 if(idx == 352)
					 {
						 printf("write terminate command \n");
					   efdata = ef16data(0x00, 0x00);
             ProgEfuseHword(idx, efdata);
					 }
					 else
					 {
					    printf("write delay command \n");
					    efdata = ef16data(0xFD, 0xFF);
              ProgEfuseHword(idx, efdata);
					 }
				 }
				 else
				 { 
					 printf("set delay of 83 us \n");
           efdata = ef16data(0x71, 0x05);
				   ProgEfuseHword(idx, efdata);
			   }
			 }				 
}



FUNC void Program_unique_serial_no()
{  
	  //unique serial
   ProgEfuseWrite(980, 0x54);
   ProgEfuseWrite(981, 0x14);
	 ProgEfuseWrite(982, 0x32);
	 ProgEfuseWrite(983, 0x5f);
	 ProgEfuseWrite(984, 0x44);
	 ProgEfuseWrite(985, 0x89);
 	 ProgEfuseWrite(986, 0x12);
	 ProgEfuseWrite(987, 0x08);
	
}

FUNC void change_life_cycle(void)
{
	  int idx;
	  int efdata;

    idx = 0;
    efdata = 0;
	
	  idx = 174;
	
	  life_cycle_iter = 2;//MFG
		//life stage
		/*Bits[7:0] Life Cycle [7:0]
    Glacier Life Cycle [8:0] = Life Cycle Mode
    #define LFE_CYLE_MODE_RAW          (0x0000ul) //000_000_000
    #define LFE_CYLE_MODE_MFG          (0x0005ul) //000_000_101
    #define LFE_CYLE_MODE_DEV          (0x001Dul) //000_001_101
    #define LFE_CYLE_MODE_PRO          (0x0035ul) //000_011_101
    #define LFE_CYLE_MODE_0FA          (0x017Dul) //101_111_101
    #define LFE_CYLE_MODE_EOL          (0x01FFul) //111_111_111*/
	  if(life_cycle_iter == 0)
		{
      efdata = ef16data( 0x00, 0x00);
    }
		else if(life_cycle_iter == 1)
		{
			efdata = ef16data( 0x05, 0x00);
		}
		else if(life_cycle_iter == 2)
		{
			efdata = ef16data( 0x1D, 0x02);
		}
		else if(life_cycle_iter == 3)
		{
			efdata = ef16data( 0x35, 0x02);
		}
		else if(life_cycle_iter == 4)
		{
			efdata = ef16data( 0x17D, 0x00);
		}
		else
		{
			efdata = ef16data( 0x1FF, 0x00);
		}
    ProgEfuseHword(idx, efdata);
		life_cycle_iter++;
}

FUNC void read_rom_log(void)
{
	printf("ROM log @ 0x126f02 sets life cycle = %08X\n", _RDWORD(0x126f02));
}

FUNC void program_E_UDS(void)
{
	
	  int idx;
    int efdata;
    int i;
	  int val;
	  int val2;
	  val = 2;
	  val2 = 3;
	  
    idx = 112;
    efdata = 0;
	  
	  for (i=0;i< 16; i++)
		{ 
			efdata = ef16data( val, val2);
      ProgEfuseHword(idx, efdata);
			idx =  idx + 1;
			val = val + 2;
			val2 = val2 + 3;
		}
	
}

FUNC void program_hash_of_ac(void)
{
	  int idx;
    int efdata;

    idx = 0;
    efdata = 0;
	
	  idx = 136;
    efdata = ef16data( 0x94, 0xac);
    
    ProgEfuseHword(idx, efdata);
	
	  idx = 137;
    efdata = ef16data( 0x24, 0x85);
    
    ProgEfuseHword(idx, efdata);
	
		idx = 138;
    efdata = ef16data( 0x60, 0xf1);
    
    ProgEfuseHword(idx, efdata);
	
	  idx = 139;
    efdata = ef16data( 0xa6, 0x06);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 140;
    efdata = ef16data( 0x66, 0x3f);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 141;
    efdata = ef16data( 0xcd, 0x14);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 142;
    efdata = ef16data( 0xf7, 0x1e);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 143;
    efdata = ef16data( 0x92, 0x1d);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 144;
    efdata = ef16data( 0xde, 0x55);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 145;
    efdata = ef16data( 0x8b, 0x2c);
 
    ProgEfuseHword(idx, efdata);
		
		idx = 146;
    efdata = ef16data( 0xb3, 0x3d);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 147;
    efdata = ef16data( 0xb5, 0xae);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 148;
    efdata = ef16data( 0x20, 0xc4);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 149;
    efdata = ef16data( 0x3c, 0x4e);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 150;
    efdata = ef16data( 0x30, 0xd3);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 151;
    efdata = ef16data( 0xe4, 0x1d);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 152;
    efdata = ef16data( 0xdf, 0x5d);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 153;
    efdata = ef16data( 0xe1, 0x81);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 154;
    efdata = ef16data( 0xb5, 0x82);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 155;
    efdata = ef16data( 0xa9, 0x6b);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 156;
    efdata = ef16data( 0xc7, 0x82);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 157;
    efdata = ef16data( 0x72, 0xe5);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 158;
    efdata = ef16data( 0x45, 0x0a);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 159;
    efdata = ef16data( 0x3b, 0x73);
    
    ProgEfuseHword(idx, efdata);
}

FUNC void prog_seed(void)
{
		int idx;
    int efdata;
    int i;
	  int val;
	  int val2;
	  val = 2;
	  val2 = 3;
	  
    idx = 208;
    efdata = 0;
	  
	  for (i=0;i< 16; i++)
		{ 
			efdata = ef16data( val, val2);
      ProgEfuseHword(idx, efdata);
			idx =  idx + 1;
			val = val * 2;
			val2 = val2 + 3;
		}
}

FUNC void ProgEfuseEN_ECDH(void) {
    int idx;
    int efdata;

    idx = 0;
    efdata = 0;
    if(once){
        //printf("Start eFUSE Programming\n");
    }

    //printf("After soft reset (bit[1] set) eFUSE control = %08X\n", _RDWORD(0x40082000));
    RUN_TST = 1;


    BOOT_OPT_92 = 0x00;


    // index is the zero based index of half-words (16-bit) quantities
    // MEC2016 eFUSE contains 4096 bits or 256 half-words.
    idx = BOOT_OPT_48;
    idx = idx | 0x98;
    BOOT_OPT_48 = idx;


    idx = BOOT_OPT_50;
    idx = idx | 0x01;
    BOOT_OPT_50 = idx;
    idx = 0;
    efdata = ef16data( 0x49, 0xd2);
    
    ProgEfuseHword(idx, efdata);

    idx = 1;
    efdata = ef16data( 0x8f, 0x18);
    
    ProgEfuseHword(idx, efdata);
		

    idx = 2;
    efdata = ef16data( 0xee, 0xc2);
    
    ProgEfuseHword(idx, efdata);

    idx = 3;
    efdata = ef16data( 0x88, 0x4e);
    
    ProgEfuseHword(idx, efdata);

    idx = 4;
    efdata = ef16data( 0x94, 0xb1);
    
    ProgEfuseHword(idx, efdata);

    idx = 5;
    efdata = ef16data( 0x31, 0x2c);
    
    ProgEfuseHword(idx, efdata);

    idx = 6;
    efdata = ef16data( 0x58, 0x28);
    
    ProgEfuseHword(idx, efdata);

    idx = 7;
    efdata = ef16data( 0x4f, 0xaa);
    
    ProgEfuseHword(idx, efdata);

    idx = 8;
    efdata = ef16data( 0xbc, 0x7d);
    
    ProgEfuseHword(idx, efdata);

    idx = 9;
    efdata = ef16data( 0x2f, 0x27);
    
    ProgEfuseHword(idx, efdata);

    idx = 10;
    efdata = ef16data( 0xf9, 0x02);
    
    ProgEfuseHword(idx, efdata);

    idx = 11;
    efdata = ef16data( 0x30, 0x1a);
    
    ProgEfuseHword(idx, efdata);

    idx = 12;
    efdata = ef16data( 0x18, 0x50);
    
    ProgEfuseHword(idx, efdata);

    idx = 13;
    efdata = ef16data( 0xd7, 0x15);
    
    ProgEfuseHword(idx, efdata);

    idx = 14;
    efdata = ef16data( 0xf1, 0xa4);
    
    ProgEfuseHword(idx, efdata);

    idx = 15;
    efdata = ef16data( 0x52, 0x40);
    
    ProgEfuseHword(idx, efdata);

    idx = 16;
    efdata = ef16data( 0x44, 0x37);
    
    ProgEfuseHword(idx, efdata);

    idx = 17;
    efdata = ef16data( 0xe1, 0x87);
    
    ProgEfuseHword(idx, efdata);

    idx = 18;
    efdata = ef16data( 0xda, 0x12);
    
    ProgEfuseHword(idx, efdata);

    idx = 19;
    efdata = ef16data( 0x6c, 0x95);
    
    ProgEfuseHword(idx, efdata);

    idx = 20;
    efdata = ef16data( 0x9d, 0x03);
    
    ProgEfuseHword(idx, efdata);

    idx = 21;
    efdata = ef16data( 0x28, 0x7a);
    
    ProgEfuseHword(idx, efdata);

    idx = 22;
    efdata = ef16data( 0x24, 0x83);
    
    ProgEfuseHword(idx, efdata);

    idx = 23;
    efdata = ef16data( 0xa1, 0xb5);
    
    ProgEfuseHword(idx, efdata);

    idx = 24; // bytes 48, 49
    //efdata = ef16data(0x98, 0xB7);//ATE mode,TFDP,GPIO0015 test, jtag enabled on rom entry
    efdata = ef16data(0x98, 0xF7); // vs ASIC
    ProgEfuseHword(idx, efdata);
		

		
    idx = 25; //boot from qspi0/1/int boot sources, INTERNAL SPI SOURCE selected
    efdata = ef16data(0x72, 0x04);  //byte 51 bit 7 -sram retention
    
    ProgEfuseHword(idx, efdata);
 
		

    idx = 26;
    efdata = ef16data(0x77, 0x14);
    
    ProgEfuseHword(idx, efdata);

    idx = 27;
    efdata = ef16data(0xA0, 0x2B);
    
    ProgEfuseHword(idx, efdata);

    idx = 28;
    efdata = ef16data(0x13, 0x33);
    
    ProgEfuseHword(idx, efdata);


    idx = 29;
    efdata = ef16data(0x63, 0x96);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 30;
    efdata = ef16data(0x02, 0x00); //feature lock register test (60, 61)//rom puf1 unlocked
    
    ProgEfuseHword(idx, efdata);
		
	idx = 31; //byte 63 
    //efdata = ef16data(0x00, 0x7A); //bit 6 = 1, UDS source is OTP, E(UDS) programmed in OTP
		efdata = ef16data(0x00, 0x3A); //bit 6 = 0, UDS source is PUF
		//Byte 63 - bit1: Generate E(UDS), bit 3 E(UDS) not programmed,bit 5 use //serial no, 
		//TRNG SELECT = DRBG (bit 4)
    ProgEfuseHword(idx, efdata);
		
				
    //bytes 89 - 93 is undefined!!


    idx = 47;
    efdata = ef16data(0x00, 0x10);  //94, 95 - Bit[0] Lock 32kHz SiOSC
    
    ProgEfuseHword(idx, efdata);
		
		idx = 56;
    efdata = ef16data(0x0f, 0x00);  //EMC present, MCM package - , 112 - regulator, voltage , band, sleep running trim enabled
    
    ProgEfuseHword(idx, efdata);

	 idx = 57; //byte 114 is undefined
    efdata = ef16data(0x00, 0x00); 
	//efdata = ef16data(0x00, 0x07); //bit 0 = 1 => external 32 kHz pin used as PLL reference clock
    
    ProgEfuseHword(idx, efdata);

	   idx = 58; //byte 117 is undefined

		//efdata = ef16data(0x10, 0x00); //E(DEVIK)priv value not programmed in otp;0 = TRNG Seed value not //programmed in OTP
    efdata = ef16data(0x08, 0x00);
    //116, bit 5:  = 0 Hash (AC) not programmed in OTP 272-319
    ProgEfuseHword(idx, efdata);

	

    //ecdh2 pubkey hash
		//ecdh2 pubkey hash
		idx = 64 ;
    efdata = ef16data( 0x54, 0x94);
    
    ProgEfuseHword(idx, efdata);

    idx = 65 ;
    efdata = ef16data( 0xc3, 0xad);
    
    ProgEfuseHword(idx, efdata);

    idx = 66 ;
    efdata = ef16data( 0xf3, 0x35);
    
    ProgEfuseHword(idx, efdata);

    idx = 67 ;
    efdata = ef16data( 0x54, 0xd8);
    
    ProgEfuseHword(idx, efdata);

    idx = 68 ;
    efdata = ef16data( 0x5f, 0xb8);
    
    ProgEfuseHword(idx, efdata);

    idx = 69 ;
    efdata = ef16data( 0x86, 0x4b);
    
    ProgEfuseHword(idx, efdata);

    idx = 70 ;
    efdata = ef16data( 0x48, 0x8c);
    
    ProgEfuseHword(idx, efdata);

    idx = 71 ;
    efdata = ef16data( 0x63, 0xf9);
    
    ProgEfuseHword(idx, efdata);

    idx = 72 ;
    efdata = ef16data( 0x6f, 0x84);
    
    ProgEfuseHword(idx, efdata);

    idx = 73 ;
    efdata = ef16data( 0x3c, 0xa9);
    
    ProgEfuseHword(idx, efdata);

    idx = 74 ;
    efdata = ef16data( 0x17, 0x24);
    
    ProgEfuseHword(idx, efdata);

    idx = 75 ;
    efdata = ef16data( 0xf5, 0xe4);
    
    ProgEfuseHword(idx, efdata);

    idx = 76 ;
    efdata = ef16data( 0xeb, 0x73);
    
    ProgEfuseHword(idx, efdata);

    idx = 77 ;
    efdata = ef16data( 0xb1, 0x93);
    
    ProgEfuseHword(idx, efdata);

    idx = 78 ;
    efdata = ef16data( 0xf7, 0xc9);
    
    ProgEfuseHword(idx, efdata);

    idx = 79 ;
    efdata = ef16data( 0x0f, 0x37);
    
    ProgEfuseHword(idx, efdata);

    idx = 80 ;
    efdata = ef16data( 0x26, 0x65);
    
    ProgEfuseHword(idx, efdata);

    idx = 81 ;
    efdata = ef16data( 0x83, 0x8d);
    
    ProgEfuseHword(idx, efdata);

    idx = 82 ;
    efdata = ef16data( 0x57, 0xd8);
    
    ProgEfuseHword(idx, efdata);

    idx = 83 ;
    efdata = ef16data( 0xf3, 0x6c);
    
    ProgEfuseHword(idx, efdata);

    idx = 84 ;
    efdata = ef16data( 0x23, 0xd2);
    
    ProgEfuseHword(idx, efdata);

    idx = 85 ;
    efdata = ef16data( 0x07, 0x39);
    
    ProgEfuseHword(idx, efdata);

    idx = 86 ;
    efdata = ef16data( 0xd6, 0x79);
    
    ProgEfuseHword(idx, efdata);

    idx = 87 ;
    efdata = ef16data( 0xf7, 0x95);
    
    ProgEfuseHword(idx, efdata);
		
		//ecdh2 key hash end

		
		//program E(UDS) for puf enabled
		program_E_UDS();
    
    ProgEfuseHword(idx, efdata);
		
		idx = 129; //Primary Flash Storage Address - Activation code using PUF1
    efdata = ef16data( 0x30, 0x00); 
    
    ProgEfuseHword(idx, efdata);
		
		idx = 130; //Fallback Flash Storage Address - Activation code using PUF1
    efdata = ef16data( 0x00, 0x10); 
    
    ProgEfuseHword(idx, efdata);
	
		
		//HASH(AC) programmed already to check for PUF test on soft reset
		
		//program_hash_of_ac();
		
	  idx = 160;
    efdata = ef16data( 0x00, 0x00);//if image revision byte 0 = 1, primary image revoked
    
    ProgEfuseHword(idx, efdata);
		
		idx = 168;
    efdata = ef16data( 0x00, 0x00);//revoke ECDSA owner keys
    
    ProgEfuseHword(idx, efdata);
		
		
    change_life_cycle();//set to MFG
		
		
	//OWNER1 BIT SET ; current owner = owner3, transfer of owner = 00 
	idx = 175;
    efdata = ef16data( 0x00, 0x01);//owner 3 is current owner
    
    ProgEfuseHword(idx, efdata);
		
    idx = 176;   
    efdata = ef16data(0x16, 0x03); // Platform ID 
    ProgEfuseHword(idx, efdata);

    idx = 177;
		efdata = ef16data (0x7F, 0xA1);//for soft reset case, otp crc check will be set already by rom
    //efdata = ef16data (0x7F, 0xA1); //manual key revocation enabled; Roll back protection enabled; enable crc32 check of trf ownership
    //Enable DICE
    //DICE SHA SELECT 384 supported, E(UDS) CRC is removed, Use serial no for E(UDS) removed from this byte
    //wdt recovery delay = 01 default - 500 ms
		
    ProgEfuseHword(idx, efdata);
    
    //Flash crisis recovery strap selection
    //Crisis flash component select
    idx = 178;
    //efdata = ef16data(0x00, 0xC4);//flash crisis recovery disabled; crisis component = internal, uart crisis mode disabled
    efdata = ef16data(0x00, 0x44); //uart enable
    //byte 357 - bit 3 = DevAKpriv encryption enabled b4 storing in sram mailbox
    ProgEfuseHword(idx, efdata);

    idx = 179;
    efdata = ef16data(0x8F, 0x00);//Authentication and encryption enabled for spi image
    ProgEfuseHword(idx, efdata);
	
    //crisis used
    idx = 183;//byte 366 - bit 6 - status reporting enabled 
		//byte 367  - I2C crisis mode disabled
    efdata = ef16data( 0x40, 0xE9); 
    //efdata = ef16data( 0x40, 0x29);//bstrap & sig enable/disable
    //efdata = ef16data( 0x40, 0x09);//ld fail
    
    ProgEfuseHword(idx, efdata);
 /*   
 //commented
		idx = 184;
    efdata = ef16data( 0x87, 0xde); 
    
    ProgEfuseHword(idx, efdata);

    idx = 185;
    efdata = ef16data( 0x42, 0x77);
    
    ProgEfuseHword(idx, efdata);

    idx = 186;
    efdata = ef16data( 0xc2, 0xb5);
    
    ProgEfuseHword(idx, efdata);

    idx = 187;
    efdata = ef16data( 0x38, 0xf5);
    
    ProgEfuseHword(idx, efdata);

    idx = 188;
    efdata = ef16data( 0x5f, 0x65);
    
    ProgEfuseHword(idx, efdata);

    idx = 189;
    efdata = ef16data( 0xe2, 0x85);
    
    ProgEfuseHword(idx, efdata);

    idx = 190;
    efdata = ef16data( 0x85, 0x06);
    
    ProgEfuseHword(idx, efdata);

    idx = 191;
    efdata = ef16data( 0x23, 0x0a);
    
    ProgEfuseHword(idx, efdata);

    idx = 192;
    efdata = ef16data( 0x26, 0xab);
    
    ProgEfuseHword(idx, efdata);

    idx = 193;
    efdata = ef16data( 0xc1, 0xf4);
    
    ProgEfuseHword(idx, efdata);

    idx = 194;
    efdata = ef16data( 0x46, 0x47);
    
    ProgEfuseHword(idx, efdata);

    idx = 195;
    efdata = ef16data( 0xd4, 0x84);
    
    ProgEfuseHword(idx, efdata);

    idx = 196;
    efdata = ef16data( 0xdd, 0x6c);
    
    ProgEfuseHword(idx, efdata);

    idx = 197;
    efdata = ef16data( 0x47, 0x83);
    
    ProgEfuseHword(idx, efdata);

    idx = 198;
    efdata = ef16data( 0x24, 0xa8);
    
    ProgEfuseHword(idx, efdata);

    idx = 199;
    efdata = ef16data( 0xa2, 0xc3);
    
    ProgEfuseHword(idx, efdata);

    idx = 200;
    efdata = ef16data( 0x77, 0xf4);
    
    ProgEfuseHword(idx, efdata);

    idx = 201;
    efdata = ef16data( 0x76, 0x0f);
    
    ProgEfuseHword(idx, efdata);

    idx = 202;
    efdata = ef16data( 0x6b, 0x81);
    
    ProgEfuseHword(idx, efdata);

    idx = 203;
    efdata = ef16data( 0xd9, 0x86);
    
    ProgEfuseHword(idx, efdata);

    idx = 204;
    efdata = ef16data( 0x4d, 0x1f);
    
    ProgEfuseHword(idx, efdata);

    idx = 205;
    efdata = ef16data( 0xe6, 0x55);
    
    ProgEfuseHword(idx, efdata);

    idx = 206;
    efdata = ef16data( 0x89, 0x1b);
    
    ProgEfuseHword(idx, efdata);

    idx = 207;
    efdata = ef16data( 0x3c, 0xd3);
    
    ProgEfuseHword(idx, efdata);

*/
//start
//384 - adithya providedlatest for container
    idx = 184;
    efdata = ef16data (0x6A, 0x54);
    ProgEfuseHword(idx, efdata); 
    
    idx = 185;
    efdata = ef16data (0xF4, 0x53); 
    ProgEfuseHword(idx, efdata);
    
    idx = 186;
    efdata = ef16data (0x25, 0xFC); 
    ProgEfuseHword(idx, efdata);
    
    idx = 187;
    efdata = ef16data (0x81, 0x5B); 
    ProgEfuseHword(idx, efdata);
    
    idx = 188;
    efdata = ef16data (0x1E, 0xBA); 
    ProgEfuseHword(idx, efdata);
    
    idx = 189;
    efdata = ef16data (0x28, 0x21); 
    ProgEfuseHword(idx, efdata);
    
    idx = 190;
    efdata = ef16data (0xBE, 0x2C); 
    ProgEfuseHword(idx, efdata);
    
    idx = 191;
    efdata = ef16data (0x6B, 0xFC);
    ProgEfuseHword(idx, efdata);
    
    idx = 192;
    efdata = ef16data (0x8B, 0xA4); 
    ProgEfuseHword(idx, efdata);
    
    idx = 193;
    efdata = ef16data (0xB9, 0xD9); 
    ProgEfuseHword(idx, efdata);
    
    idx = 194;
    efdata = ef16data (0x82, 0x87); 
    ProgEfuseHword(idx, efdata);
    
    idx = 195;
    efdata = ef16data (0xDC, 0x6C); 
    ProgEfuseHword(idx, efdata);
    
    idx = 196;
    efdata = ef16data (0x21, 0x22); 
    ProgEfuseHword(idx, efdata);
    
    idx = 197;
    efdata = ef16data (0xD1, 0xDD); 
    ProgEfuseHword(idx, efdata);
    
    idx = 198;
    efdata = ef16data (0xAF, 0xA9); 
    ProgEfuseHword(idx, efdata);
    
    idx = 199;
    efdata = ef16data (0x59, 0xB7);
    ProgEfuseHword(idx, efdata);
    
    idx = 200;
    efdata = ef16data (0xC5, 0xD1); 
    ProgEfuseHword(idx, efdata);
    
    idx = 201;
    efdata = ef16data (0x2E, 0x6A); 
    ProgEfuseHword(idx, efdata);
    
    idx = 202;
    efdata = ef16data (0x01, 0x90); 
    ProgEfuseHword(idx, efdata);
    
    idx = 203;
    efdata = ef16data (0x02, 0x94); 
    ProgEfuseHword(idx, efdata);
    
    idx = 204;
    efdata = ef16data (0x59, 0x8F); 
    ProgEfuseHword(idx, efdata);
    
    idx = 205;
    efdata = ef16data (0xDE, 0x30); 
    ProgEfuseHword(idx, efdata);
    
    idx = 206;
    efdata = ef16data (0x29, 0x95); 
    ProgEfuseHword(idx, efdata);
    
    idx = 207;
    efdata = ef16data (0x2F, 0xF6);
    ProgEfuseHword(idx, efdata);
               


//end


   prog_seed();


	 //Following below otp offsets for EC FW req
	 //EC FW SPECIFIC USED DURING EC FW EXECUTION!
	 
	  idx = 412;
    efdata = ef16data(0x10, 0x00); //AP BA PTR0 base address
    
    ProgEfuseHword(idx, efdata);
		
	  idx = 414;
    efdata = ef16data(0x20, 0x00); //AP BA PTR0 base address
    
    ProgEfuseHword(idx, efdata);
		
		idx = 423;
    efdata = ef16data(0x05, 0x00);  // AP Public key count
    
    ProgEfuseHword(idx, efdata);
	 
	  idx = 424;
    efdata = ef16data(0x2c, 0x0e); //  AP Optional Feature Configuration - Byte 1,
		                               //  AP Optional Feature Configuration - Byte 2, ASYNC_RST_DET,EXTRST_IN 
																	 //  and EXTRST not presentt
    
    ProgEfuseHword(idx, efdata);
		
		 idx = 426;                    //  AP features option source
    efdata = ef16data(0x30, 0x00); 
    
    ProgEfuseHword(idx, efdata);
		
		idx = 428;                     //  AP Feature options byte - 5
    efdata = ef16data(0x00, 0x12); 
     
    ProgEfuseHword(idx, efdata);
		
		idx = 429;                     //  AP Feature options byte - 6
    efdata = ef16data(0x12, 0x00); 
     
    ProgEfuseHword(idx, efdata);

		idx = 430;                     //  address in internal flash for IK certificate
    efdata = ef16data(0x00, 0x20); 
	ProgEfuseHword(idx, efdata);
	
		idx = 431;                     //  address in internal flash for IK certificate
    efdata = ef16data(0x00, 0x00); 
    ProgEfuseHword(idx, efdata);
    
    //vs - start
//864-911
//912-960
// 0512 - 0519 //0x2B, 0xAC, 0x23, 0x0A, 0x4C, 0x07, 0xCE, 0xD8,
// 0520 - 0527 //0x13, 0x40, 0xFD, 0x78, 0x97, 0xAF, 0x23, 0xDE,
// 0528 - 0535 //0x00, 0x4C, 0x97, 0x7C, 0x9C, 0x65, 0x2B, 0x24,
// 0536 - 0543 //0xEA, 0x4B, 0x59, 0xCF, 0x47, 0x12, 0x1E, 0x8B,
// 0544 - 0551 //0x6E, 0xCF, 0xE5, 0x71, 0x47, 0x21, 0x68, 0xBB,
// 0552 - 0559 //0x46, 0x38, 0x0D, 0xB1, 0xBA, 0xE3, 0x0B, 0x93,
    
    //----512-519
    //efdata = ef16data(0x12, 0x34); //invalid for test purpose
    efdata = ef16data(0x2B, 0xAC);
    ProgEfuseHword(432, efdata);
    
    efdata = ef16data(0x23, 0x0A);
    ProgEfuseHword(433, efdata);
    
    efdata = ef16data(0x4C, 0x07);
    ProgEfuseHword(434, efdata);
    
    efdata = ef16data(0xCE, 0xD8);
    ProgEfuseHword(435, efdata);
    
    //-----------520-527
    efdata = ef16data(0x13, 0x40);
    ProgEfuseHword(436, efdata);
    
    efdata = ef16data(0xFD, 0x78);
    ProgEfuseHword(437, efdata);
    
    efdata = ef16data(0x97, 0xAF);
    ProgEfuseHword(438, efdata);
    
    efdata = ef16data(0x23, 0xDE);
    ProgEfuseHword(439, efdata);
    
    //--------528-535
    efdata = ef16data(0x00, 0x4C);
    ProgEfuseHword(440, efdata);
    
    efdata = ef16data(0x97, 0x7C);
    ProgEfuseHword(441, efdata);
    
    efdata = ef16data(0x9C, 0x65);
    ProgEfuseHword(442, efdata);
    
    efdata = ef16data(0x2B, 0x24);
    ProgEfuseHword(443, efdata);
    //-----------
    
    //----536-543
    efdata = ef16data(0xEA, 0x4B);
    ProgEfuseHword(444, efdata);
    
    efdata = ef16data(0x59, 0xCF);
    ProgEfuseHword(445, efdata);
    
    efdata = ef16data(0x47, 0x12);
    ProgEfuseHword(446, efdata);
    
    efdata = ef16data(0x1E, 0x8B);
    ProgEfuseHword(447, efdata);

    //----544-551
    efdata = ef16data(0x6E, 0xCF);
    ProgEfuseHword(448, efdata);
    
    efdata = ef16data(0xE5, 0x71);
    ProgEfuseHword(449, efdata);
    
    efdata = ef16data(0x47, 0x21);
    ProgEfuseHword(450, efdata);
    
    efdata = ef16data(0x68, 0xBB);
    ProgEfuseHword(451, efdata);

    //----552-559    
    efdata = ef16data(0x46, 0x38);
    ProgEfuseHword(452, efdata);
    
    efdata = ef16data(0x0D, 0xB1);
    ProgEfuseHword(453, efdata);
    
    efdata = ef16data(0xBA, 0xE3);
    ProgEfuseHword(454, efdata);
    
    efdata = ef16data(0x0B, 0x93);
    ProgEfuseHword(455, efdata);
    
//vs - end

// vs - start
// 0560 - 0567 0x41 ,0x47 ,0xDC ,0x07 ,0x47 ,0x7C ,0x39 ,0x9C,
// 0568 - 0575 0x5A ,0x8E ,0x28 ,0x19 ,0x23 ,0xB5 ,0xDF ,0x26,
// 0576 - 0583 0xD7 ,0xFB ,0xDA ,0x38 ,0xC5 ,0x9A ,0x29 ,0x7A,
// 0584 - 0591 0x78 ,0xAB ,0xF6 ,0xA6 ,0x63 ,0xC9 ,0xC0 ,0xA9,
// 0592 - 0599 0x9C ,0x7B ,0x8E ,0x3F ,0xE0 ,0xDC ,0x78 ,0x79,
// 0600 - 0607 0x05 ,0x13 ,0x5F ,0x8B ,0x8E ,0xA5 ,0x57 ,0xFD,
            
    //----0560 - 0567    
    efdata = ef16data(0x41, 0x47);
    ProgEfuseHword(456, efdata);
    
    efdata = ef16data(0xDC, 0x07);
    ProgEfuseHword(457, efdata);
    
    efdata = ef16data(0x47, 0x7C);
    ProgEfuseHword(458, efdata);
    
    efdata = ef16data(0x39, 0x9C);
    ProgEfuseHword(459, efdata);
    
    
    //----0568 - 0575
    efdata = ef16data(0x5A, 0x8E);
    ProgEfuseHword(460, efdata);
    
    efdata = ef16data(0x28, 0x19);
    ProgEfuseHword(461, efdata);
    
    efdata = ef16data(0x23, 0xB5);
    ProgEfuseHword(462, efdata);
    
    efdata = ef16data(0xDF, 0x26);
    ProgEfuseHword(463, efdata);
    
    //----576-583
    efdata = ef16data(0xD7, 0xFB);
    ProgEfuseHword(464, efdata);
    
    efdata = ef16data(0xDA, 0x38);
    ProgEfuseHword(465, efdata);
    
    efdata = ef16data(0xC5, 0x9A);
    ProgEfuseHword(466, efdata);
    
    efdata = ef16data(0x29, 0x7A);
    ProgEfuseHword(467, efdata);
    
    //----584-591
    efdata = ef16data(0x78, 0xAB);
    ProgEfuseHword(468, efdata);
    
    efdata = ef16data(0xF6, 0xA6);
    ProgEfuseHword(469, efdata);
    
    efdata = ef16data(0x63, 0xC9);
    ProgEfuseHword(470, efdata);
    
    efdata = ef16data(0xC0, 0xA9);
    ProgEfuseHword(471, efdata);
    
    //-----------592-599
    efdata = ef16data(0x9C, 0x7B);
    ProgEfuseHword(472, efdata);
    
    efdata = ef16data(0x8E, 0x3F);
    ProgEfuseHword(473, efdata);
    
    efdata = ef16data(0xE0, 0xDC);
    ProgEfuseHword(474, efdata);
    
    efdata = ef16data(0x78, 0x79);
    ProgEfuseHword(475, efdata);
    
    //--------600-608
    efdata = ef16data(0x05, 0x13);
    ProgEfuseHword(476, efdata);
    
    efdata = ef16data(0x5F, 0x8B);
    ProgEfuseHword(477, efdata);
    
    efdata = ef16data(0x8E, 0xA5);
    ProgEfuseHword(478, efdata);
    
    efdata = ef16data(0x57, 0xFD);
    ProgEfuseHword(479, efdata);

    
// vs - end
		
	  idx = 494;                     //  Customer ID
    efdata = ef16data(0x01, 0xfe); 
     
    ProgEfuseHword(idx, efdata);
		
		 idx = 495;                     //  OTP revision ID, ec fw major revision
    efdata = ef16data(0x00, 0x00); 
     
    ProgEfuseHword(idx, efdata);
		
		
		//END OF EC FW SPECIFIC OTP OFFSET CONFIGURATION
		
    idx = 480;
    efdata = ef16data(0x00, 0x00); //no otp bytes (351 - 320) read locked
    
    ProgEfuseHword(idx, efdata);
		

    idx = 484;
    efdata = ef16data(0x00, 0x00);
    // 968 byte - OTP memory is not write locked (OTP WRITE SECURE_LOCK)
    // 969 byte - OTP memory is not read locked (OTP READ SECURE_LOCK)
    
    ProgEfuseHword(idx, efdata);

    //otp bytes used for Config lock (970 - 974)
		
		
		idx = 485;
    efdata = ef16data(0x01, 0x00);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 487;
    efdata = ef16data(0x00, 0x00);
    
    ProgEfuseHword(idx, efdata);


    //otp 980-987
	 Program_unique_serial_no();
   
	 
	//tag0/1 base pointer and flash component base address
	  idx = 496;
    efdata = ef16data(0x00, 0x00);
    
    ProgEfuseHword(idx, efdata);
	
		
	  idx = 498;
    efdata = ef16data(0x06, 0x00);
    
    ProgEfuseHword(idx, efdata);
		
    idx = 511;
    efdata = ef16data(0x78, 0x12); //validation, otp ID's
    
    ProgEfuseHword(idx, efdata);
		
}

FUNC void raw_mode_test(void) {
    int idx;
    int efdata;

    idx = 0;
    efdata = 0;
	
		idx = 174;

    efdata = ef16data( 0x00, 0x00);
	  ProgEfuseHword(idx, efdata);
}


FUNC void set_life_req(void) {
	
	exec("BS 0x16a0e, r1 = 1");//set life cycle req
}

FUNC void raw_mode_set_bndry_scan(void) {
	
	exec("BS 0x15492, r0 = 4");//set bndry scan
}

FUNC void print_debug_reg_state(void){
	
	
	printf("DEBUG reg  = %08X\n", _RWORD(0x4000FC20));
	
	printf("STAP test status = %08X\n", _RWORD(0x4000fc8c));

}


FUNC void enter_mfg_mode(void) {
    int idx;
    int efdata;

    idx = 0;
    efdata = 0;
    if(once){
        //printf("Start eFUSE Programming\n");
    }

    //printf("After soft reset (bit[1] set) eFUSE control = %08X\n", _RDWORD(0x40082000));
    RUN_TST = 1;


    BOOT_OPT_92 = 0x00;


    // index is the zero based index of half-words (16-bit) quantities
    // MEC2016 eFUSE contains 4096 bits or 256 half-words.
    idx = BOOT_OPT_48;
    idx = idx | 0x98;
    BOOT_OPT_48 = idx;


    idx = BOOT_OPT_50;
    idx = idx | 0x01;
    BOOT_OPT_50 = idx;
    idx = 0;
    efdata = ef16data( 0x49, 0xd2);
    
    ProgEfuseHword(idx, efdata);

    idx = 1;
    efdata = ef16data( 0x8f, 0x18);
    
    ProgEfuseHword(idx, efdata);
		

    idx = 2;
    efdata = ef16data( 0xee, 0xc2);
    
    ProgEfuseHword(idx, efdata);

    idx = 3;
    efdata = ef16data( 0x88, 0x4e);
    
    ProgEfuseHword(idx, efdata);

    idx = 4;
    efdata = ef16data( 0x94, 0xb1);
    
    ProgEfuseHword(idx, efdata);

    idx = 5;
    efdata = ef16data( 0x31, 0x2c);
    
    ProgEfuseHword(idx, efdata);

    idx = 6;
    efdata = ef16data( 0x58, 0x28);
    
    ProgEfuseHword(idx, efdata);

    idx = 7;
    efdata = ef16data( 0x4f, 0xaa);
    
    ProgEfuseHword(idx, efdata);

    idx = 8;
    efdata = ef16data( 0xbc, 0x7d);
    
    ProgEfuseHword(idx, efdata);

    idx = 9;
    efdata = ef16data( 0x2f, 0x27);
    
    ProgEfuseHword(idx, efdata);

    idx = 10;
    efdata = ef16data( 0xf9, 0x02);
    
    ProgEfuseHword(idx, efdata);

    idx = 11;
    efdata = ef16data( 0x30, 0x1a);
    
    ProgEfuseHword(idx, efdata);

    idx = 12;
    efdata = ef16data( 0x18, 0x50);
    
    ProgEfuseHword(idx, efdata);

    idx = 13;
    efdata = ef16data( 0xd7, 0x15);
    
    ProgEfuseHword(idx, efdata);

    idx = 14;
    efdata = ef16data( 0xf1, 0xa4);
    
    ProgEfuseHword(idx, efdata);

    idx = 15;
    efdata = ef16data( 0x52, 0x40);
    
    ProgEfuseHword(idx, efdata);

    idx = 16;
    efdata = ef16data( 0x44, 0x37);
    
    ProgEfuseHword(idx, efdata);

    idx = 17;
    efdata = ef16data( 0xe1, 0x87);
    
    ProgEfuseHword(idx, efdata);

    idx = 18;
    efdata = ef16data( 0xda, 0x12);
    
    ProgEfuseHword(idx, efdata);

    idx = 19;
    efdata = ef16data( 0x6c, 0x95);
    
    ProgEfuseHword(idx, efdata);

    idx = 20;
    efdata = ef16data( 0x9d, 0x03);
    
    ProgEfuseHword(idx, efdata);

    idx = 21;
    efdata = ef16data( 0x28, 0x7a);
    
    ProgEfuseHword(idx, efdata);

    idx = 22;
    efdata = ef16data( 0x24, 0x83);
    
    ProgEfuseHword(idx, efdata);

    idx = 23;
    efdata = ef16data( 0xa1, 0xb5);
    
    ProgEfuseHword(idx, efdata);

    idx = 24; // bytes 48, 49
    efdata = ef16data(0x98, 0x37);//Enter ATE mode,TFDP,GPIO0015 test, jtag enabled on rom entry
    ProgEfuseHword(idx, efdata);
		

		
    idx = 25; //boot from qspi0/1/int boot sources, INTERNAL SPI SOURCE selected
    efdata = ef16data(0x72, 0x04);  //byte 51 bit 7 -sram retention
    
    ProgEfuseHword(idx, efdata);
 
		

    idx = 26;
    efdata = ef16data(0x77, 0x14);
    
    ProgEfuseHword(idx, efdata);

    idx = 27;
    efdata = ef16data(0xA0, 0x2B);
    
    ProgEfuseHword(idx, efdata);

    idx = 28;
    efdata = ef16data(0x13, 0x33);
    
    ProgEfuseHword(idx, efdata);


    idx = 29;
    efdata = ef16data(0x63, 0x96);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 30;
    efdata = ef16data(0x00, 0x00); //feature lock register test (60, 61)//rom puf1 and 0 unlocked
    
    ProgEfuseHword(idx, efdata);
		
	idx = 31; //byte 63 
    //efdata = ef16data(0x00, 0x7A); //bit 6 = 1, UDS source is OTP, E(UDS) programmed in OTP
		efdata = ef16data(0x00, 0x3A); //bit 6 = 0, UDS source is PUF
		//Byte 63 - bit1: Generate E(UDS), bit 3 E(UDS) not programmed,bit 5 use //serial no, 
		//TRNG SELECT = DRBG (bit 4)
    ProgEfuseHword(idx, efdata);
		
				
    //bytes 89 - 93 is undefined!!
		


    idx = 47;
    efdata = ef16data(0x00, 0x00);  //INT_SPI_IO2 and INT_SPI_IO2 to push pull output high
    
    ProgEfuseHword(idx, efdata);
		
		idx = 56;
    efdata = ef16data(0x0f, 0x00);  //EMC present, MCM package - , 112 - regulator, voltage , band, sleep running trim enabled
    
    ProgEfuseHword(idx, efdata);

	 idx = 57; //byte 114 is undefined
    efdata = ef16data(0x00, 0x00); 
	//efdata = ef16data(0x00, 0x07); //bit 0 = 1 => external 32 kHz pin used as PLL reference clock
    
    ProgEfuseHword(idx, efdata);

	   idx = 58; //byte 117 is undefined

		efdata = ef16data(0x40, 0x00); //E(DEVIK)priv value not programmed in otp;0 = TRNG Seed value not //programmed in OTP
    //116, bit 5:  = 0 Hash (AC) programmed in OTP 272-319; generate and encrypt E(DevIK) for OTP.
    ProgEfuseHword(idx, efdata);

	

    //ecdh2 pubkey hash
		//ecdh2 pubkey hash
		idx = 64 ;
    efdata = ef16data( 0x54, 0x94);
    
    ProgEfuseHword(idx, efdata);

    idx = 65 ;
    efdata = ef16data( 0xc3, 0xad);
    
    ProgEfuseHword(idx, efdata);

    idx = 66 ;
    efdata = ef16data( 0xf3, 0x35);
    
    ProgEfuseHword(idx, efdata);

    idx = 67 ;
    efdata = ef16data( 0x54, 0xd8);
    
    ProgEfuseHword(idx, efdata);

    idx = 68 ;
    efdata = ef16data( 0x5f, 0xb8);
    
    ProgEfuseHword(idx, efdata);

    idx = 69 ;
    efdata = ef16data( 0x86, 0x4b);
    
    ProgEfuseHword(idx, efdata);

    idx = 70 ;
    efdata = ef16data( 0x48, 0x8c);
    
    ProgEfuseHword(idx, efdata);

    idx = 71 ;
    efdata = ef16data( 0x63, 0xf9);
    
    ProgEfuseHword(idx, efdata);

    idx = 72 ;
    efdata = ef16data( 0x6f, 0x84);
    
    ProgEfuseHword(idx, efdata);

    idx = 73 ;
    efdata = ef16data( 0x3c, 0xa9);
    
    ProgEfuseHword(idx, efdata);

    idx = 74 ;
    efdata = ef16data( 0x17, 0x24);
    
    ProgEfuseHword(idx, efdata);

    idx = 75 ;
    efdata = ef16data( 0xf5, 0xe4);
    
    ProgEfuseHword(idx, efdata);

    idx = 76 ;
    efdata = ef16data( 0xeb, 0x73);
    
    ProgEfuseHword(idx, efdata);

    idx = 77 ;
    efdata = ef16data( 0xb1, 0x93);
    
    ProgEfuseHword(idx, efdata);

    idx = 78 ;
    efdata = ef16data( 0xf7, 0xc9);
    
    ProgEfuseHword(idx, efdata);

    idx = 79 ;
    efdata = ef16data( 0x0f, 0x37);
    
    ProgEfuseHword(idx, efdata);

    idx = 80 ;
    efdata = ef16data( 0x26, 0x65);
    
    ProgEfuseHword(idx, efdata);

    idx = 81 ;
    efdata = ef16data( 0x83, 0x8d);
    
    ProgEfuseHword(idx, efdata);

    idx = 82 ;
    efdata = ef16data( 0x57, 0xd8);
    
    ProgEfuseHword(idx, efdata);

    idx = 83 ;
    efdata = ef16data( 0xf3, 0x6c);
    
    ProgEfuseHword(idx, efdata);

    idx = 84 ;
    efdata = ef16data( 0x23, 0xd2);
    
    ProgEfuseHword(idx, efdata);

    idx = 85 ;
    efdata = ef16data( 0x07, 0x39);
    
    ProgEfuseHword(idx, efdata);

    idx = 86 ;
    efdata = ef16data( 0xd6, 0x79);
    
    ProgEfuseHword(idx, efdata);

    idx = 87 ;
    efdata = ef16data( 0xf7, 0x95);
    
    ProgEfuseHword(idx, efdata);
		
		//ecdh2 key hash end

		
		//program E(UDS) for puf enabled
		program_E_UDS();
    
    ProgEfuseHword(idx, efdata);
		
		idx = 129; //Primary Flash Storage Address - Activation code using PUF1
		//SPI Flash Base Address[11:0] = 000,
		//Bits[23:4] = 3  
		//SPI Flash Base Address[31:12] = OTP Bits[23:4] = 3, 000 will be appended by rom, Bits[3:1] Not used, bit 0 = cs0/1
    efdata = ef16data( 0x30, 0x00); //at 0x3000 spi address
    
    ProgEfuseHword(idx, efdata);
		
		idx = 130; //Fallback Flash Storage Address - Activation code using PUF1
    efdata = ef16data( 0x00, 0x10); //0x1000
    
    ProgEfuseHword(idx, efdata);
		
		
	  idx = 160;
    efdata = ef16data( 0x00, 0x00);//if image revision byte 0 = 1, primary image revoked
    
    ProgEfuseHword(idx, efdata);
		
		idx = 168;
    efdata = ef16data( 0x00, 0x00);//revoke ECDSA owner keys
    
    ProgEfuseHword(idx, efdata);
		
		
    change_life_cycle();//set to MFG
		
		
	//OWNER1 BIT SET ; current owner = owner3, transfer of owner = 00 
	idx = 175;
    efdata = ef16data( 0x00, 0x01);//owner 3 is current owner
    
    ProgEfuseHword(idx, efdata);
		
    idx = 176;   
    efdata = ef16data(0x16, 0x03); // Platform ID 
    ProgEfuseHword(idx, efdata);

    idx = 177;
		efdata = ef16data (0x7F, 0xA1);//for soft reset case, otp crc check will be set already by rom
    //efdata = ef16data (0x7F, 0xA1); //manual key revocation enabled; Roll back protection enabled; enable crc32 check of trf ownership
    //Enable DICE
    //DICE SHA SELECT 384 supported, E(UDS) CRC is removed, Use serial no for E(UDS) removed from this byte
    //wdt recovery delay = 01 default - 500 ms
		
    ProgEfuseHword(idx, efdata);
    
    //Flash crisis recovery strap selection
    //Crisis flash component select
    idx = 178;
    efdata = ef16data(0x00, 0xC4);//flash crisis recovery disabled; crisis component = internal, uart crisis mode disabled
    //byte 357 - bit 3 = DevAKpriv encryption enabled b4 storing in sram mailbox
    ProgEfuseHword(idx, efdata);

    idx = 179;
    efdata = ef16data(0x0F, 0x00);//Authentication and encryption enabled for spi image, not full provisioned
    ProgEfuseHword(idx, efdata);
	

    idx = 183;//byte 366 - bit 6 - status reporting enabled 
		//byte 367  - I2C crisis mode disabled
    //efdata = ef16data( 0xC0, 0xE2);
    //efdata = ef16data( 0xC0, 0x29);//bstrap & sig dis enable
    //efdata = ef16data( 0xC0, 0x49);//ld fail    
    
    ProgEfuseHword(idx, efdata);

				idx = 184;
    efdata = ef16data( 0x87, 0xde); 
    
    ProgEfuseHword(idx, efdata);

    idx = 185;
    efdata = ef16data( 0x42, 0x77);
    
    ProgEfuseHword(idx, efdata);

    idx = 186;
    efdata = ef16data( 0xc2, 0xb5);
    
    ProgEfuseHword(idx, efdata);

    idx = 187;
    efdata = ef16data( 0x38, 0xf5);
    
    ProgEfuseHword(idx, efdata);

    idx = 188;
    efdata = ef16data( 0x5f, 0x65);
    
    ProgEfuseHword(idx, efdata);

    idx = 189;
    efdata = ef16data( 0xe2, 0x85);
    
    ProgEfuseHword(idx, efdata);

    idx = 190;
    efdata = ef16data( 0x85, 0x06);
    
    ProgEfuseHword(idx, efdata);

    idx = 191;
    efdata = ef16data( 0x23, 0x0a);
    
    ProgEfuseHword(idx, efdata);

    idx = 192;
    efdata = ef16data( 0x26, 0xab);
    
    ProgEfuseHword(idx, efdata);

    idx = 193;
    efdata = ef16data( 0xc1, 0xf4);
    
    ProgEfuseHword(idx, efdata);

    idx = 194;
    efdata = ef16data( 0x46, 0x47);
    
    ProgEfuseHword(idx, efdata);

    idx = 195;
    efdata = ef16data( 0xd4, 0x84);
    
    ProgEfuseHword(idx, efdata);

    idx = 196;
    efdata = ef16data( 0xdd, 0x6c);
    
    ProgEfuseHword(idx, efdata);

    idx = 197;
    efdata = ef16data( 0x47, 0x83);
    
    ProgEfuseHword(idx, efdata);

    idx = 198;
    efdata = ef16data( 0x24, 0xa8);
    
    ProgEfuseHword(idx, efdata);

    idx = 199;
    efdata = ef16data( 0xa2, 0xc3);
    
    ProgEfuseHword(idx, efdata);

    idx = 200;
    efdata = ef16data( 0x77, 0xf4);
    
    ProgEfuseHword(idx, efdata);

    idx = 201;
    efdata = ef16data( 0x76, 0x0f);
    
    ProgEfuseHword(idx, efdata);

    idx = 202;
    efdata = ef16data( 0x6b, 0x81);
    
    ProgEfuseHword(idx, efdata);

    idx = 203;
    efdata = ef16data( 0xd9, 0x86);
    
    ProgEfuseHword(idx, efdata);

    idx = 204;
    efdata = ef16data( 0x4d, 0x1f);
    
    ProgEfuseHword(idx, efdata);

    idx = 205;
    efdata = ef16data( 0xe6, 0x55);
    
    ProgEfuseHword(idx, efdata);

    idx = 206;
    efdata = ef16data( 0x89, 0x1b);
    
    ProgEfuseHword(idx, efdata);

    idx = 207;
    efdata = ef16data( 0x3c, 0xd3);
    
    ProgEfuseHword(idx, efdata);


	 //Following below otp offsets for EC FW req
	 //EC FW SPECIFIC USED DURING EC FW EXECUTION!
	 
	  idx = 412;
    efdata = ef16data(0x10, 0x00); //AP BA PTR0 base address
    
    ProgEfuseHword(idx, efdata);
		
	  idx = 414;
    efdata = ef16data(0x20, 0x00); //AP BA PTR0 base address
    
    ProgEfuseHword(idx, efdata);
		
		idx = 423;
    efdata = ef16data(0x05, 0x00);  // AP Public key count
    
    ProgEfuseHword(idx, efdata);
	 
	  idx = 424;
    efdata = ef16data(0x2c, 0x0e); //  AP Optional Feature Configuration - Byte 1,
		                               //  AP Optional Feature Configuration - Byte 2, ASYNC_RST_DET,EXTRST_IN 
																	 //  and EXTRST not presentt
    
    ProgEfuseHword(idx, efdata);
		
		 idx = 426;                    //  AP features option source
    efdata = ef16data(0x30, 0x00); 
    
    ProgEfuseHword(idx, efdata);
		
		idx = 428;                     //  AP Feature options byte - 5
    efdata = ef16data(0x00, 0x12); 
     
    ProgEfuseHword(idx, efdata);
		
		idx = 429;                     //  AP Feature options byte - 6
    efdata = ef16data(0x12, 0x00); 
     
    ProgEfuseHword(idx, efdata);
    
    
		
	  idx = 494;                     //  Customer ID
    efdata = ef16data(0x01, 0xfe); 
     
    ProgEfuseHword(idx, efdata);
		
		 idx = 495;                     //  OTP revision ID, ec fw major revision
    efdata = ef16data(0x00, 0x00); 
     
    ProgEfuseHword(idx, efdata);
		
		
		//END OF EC FW SPECIFIC OTP OFFSET CONFIGURATION
		
    idx = 480;
    efdata = ef16data(0x00, 0x00); //no otp bytes (351 - 320) read locked
    
    ProgEfuseHword(idx, efdata);
		

    idx = 484;
    efdata = ef16data(0x00, 0x00);
    // 968 byte - OTP memory is not write locked (OTP WRITE SECURE_LOCK)
    // 969 byte - OTP memory is not read locked (OTP READ SECURE_LOCK)
    
    ProgEfuseHword(idx, efdata);

    //otp bytes used for Config lock (970 - 974)
		
		
		idx = 485;
    efdata = ef16data(0x01, 0x00);
    
    ProgEfuseHword(idx, efdata);
		
		idx = 487;
    efdata = ef16data(0x00, 0x00);
    
    ProgEfuseHword(idx, efdata);


    //otp 980-987
	 Program_unique_serial_no();
   
	 
	//tag0/1 base pointer and flash component base address
	  idx = 496;
    efdata = ef16data(0x00, 0x00);
    
    ProgEfuseHword(idx, efdata);
	
		
	  idx = 498;
    efdata = ef16data(0x06, 0x00);
    
    ProgEfuseHword(idx, efdata);
		
    idx = 511;
    efdata = ef16data(0x78, 0x12); //validation, otp ID's
    
    ProgEfuseHword(idx, efdata);
		
}

FUNC void exit_ate_mode(void) {
    int idx;
    int efdata;


    efdata = 0;
    idx = 24; // bytes 48, 49
	
    efdata = ef16data(0x98, 0xb7);//exit ATE mode,TFDP,GPIO0015 test, jtag enabled on rom entry
    ProgEfuseHword(idx, efdata);
}

FUNC void qa_mode_feature_disable(void) {
    int idx;
    int efdata;


    efdata = 0;
    idx = 505; 
	
    efdata = ef16data(0x20, 0x00);//disable QA mode
    ProgEfuseHword(idx, efdata);
}

FUNC void enter_full_prov_mode(void) {
    int idx;
    int efdata;

    idx = 179;
    efdata = 0;

    efdata = ef16data(0x8F, 0x00);//Authentication and encryption enabled for spi image, not full provisioned
    ProgEfuseHword(idx, efdata);
    change_life_cycle();

}

FUNC void set_tst_rqst(void){
  exec("BS 0x16906, r0 = 0x20");
}
FUNC void set_life_rq_change_from_mfg(void){
	
  exec("BS 0x1022e, r0 = 0x10");

}

FUNC void qa_mode_enable_stap(void){
	
  exec("BS 0x16714, r0=0x01");
}

FUNC void valid_mode_enable_stap(void){
	exec("BS 0x1675c, r1 = 0x02");
}

FUNC void soft_reset(void) {
  
	_WBYTE(0x40080119, 0x01);
}

_WBYTE(0x4000fd85, 0x0a); //scratch reg to enable for generating IK key, IK SOURCE IS OTP

//_WBYTE(0x4000A428, 0x01); //default image as tag1

//BS 0xC10,1,"R1=1" 
//BS 0x16a0e, 1, "r1 = 1"

//BS 0x1022e, 1, "r0 = 0x10"

//LOAD bootrom1.hex incremental
//LOAD Glacier_bootrom1_wt.hex incremental
//LOAD puf.hex 
//LOAD puf_app_revb.hex 

